### 诸葛耘墒

#### AI 视频面试

##### 最近看了什么书？或文章，有什么收获？

#### 算法题

###### 1、[有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```java
/**
 * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
 * 有效字符串需满足：
 * 左括号必须用相同类型的右括号闭合。
 * 左括号必须以正确的顺序闭合。
 **/
public boolean isValid1(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i =0;i<s.length();i++){
            if (s.charAt(i) == '('){
                stack.push(')');
            }else if (s.charAt(i) == '{'){
                stack.push('}');
            }else if (s.charAt(i) == '['){
                stack.push(']');
                // 如果不等于返回false
            }else if (stack.isEmpty() || stack.pop() != s.charAt(i)){
                return false;
            }
        }
    // 最后不为空返回false
        return stack.isEmpty();
    }
```

###### 2、 [字符串相乘](https://leetcode.cn/problems/multiply-strings/)

#### 二面(腾讯会议)

##### Spring如何解决循环依赖问题 

Spring使用了三级缓存解决了循环依赖的问题。在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完，一共执行了4次。至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。

##### AQS理论的数据结构

AQS内部有3个对象，一个是state（用于计数器，类似gc的回收计数器），一个是线程标记（当前线程是谁加锁的），一个是阻塞队列。

AQS是自旋锁，在等待唤醒的时候，经常会使用自旋的方式，不停地尝试获取锁，直到被其他线程获取成功。

AQS有两个队列，同步对列和条件队列。同步队列依赖一个双向链表来完成同步状态的管理，当前线程获取同步状态失败后，同步器会将线程构建成一个节点，并将其加入同步队列中。通过signal或signalAll将条件队列中的节点转移到同步队列。

##### 线程池执行过程

1、当前线程小于核心线程，那么马上创建线程运行这个任务

2、如果正在运行线程大于核心线程，那么将这个线程放入队列中

3、如果当队列满了，运行线程小于最大线程，创建非核心线程运行这个任务

4、如果队列满了，而且正在运行的线程数量大于或等于 最大线程数，那么线程池会执行拒绝策略

----



### 京北方

银行 SSM

##### 线程按顺序执行

1、通过检测信号，监测到信号就执行，执行完将信号改为下一个线程的信号。

2、通过FutureTask可以阻塞获取返回值的特性，顺序开启线程并获取返回值，线程将依次执行，返回结果

3、通过join()阻塞等待线程执行完，按线程执行顺序，依次join()进行阻塞

4、通过单线程线程池特性，线程池中只有一个线程，任务会在队列中，按提交顺序依次执行

##### 锁的状态？

四种状态：无锁、偏向锁、轻量级锁和重量级锁

1、无锁：没有对资源进行锁定，所有线程都能访问并修改同一份资源。

2、偏向锁：一段同步代码块一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

3、轻量锁：当锁是偏向锁时，只要被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获得锁，不会阻塞，从而提高性能。

4、重量级锁：所有等待锁的线程都会进入阻塞状态。

##### 线程的状态？

线程的六种状态：创建、就绪、运行、等待、阻塞、死亡



----

### OD

> 我们的机试在牛客网上，共三道题，分值依次是100.100.200，得300分左右能过。中等题比如最大括号深度，树，区间交集，二元数组查找等等，排序，栈，队列，字符串处理这些方向挑典型题练练。
> 机试这块，牛客网上有专门的华为机考样题可以刷：https://www.nowcoder.com/ta/huawei  另外，百度上也有不少人的机试分享，比如这篇就写得很好，可以参考学习：blog.csdn.net/tiger9991/article/details/107037724
>
> 
>
> OD真题：https://www.online1987.com/%e9%a2%98%e7%9b%ae%e5%af%bc%e8%88%aa/



---

### 刀豆网络

##### Java11新特性

1、字符串API增强

 **isBlank()**
用来判断字符串是不是空字符"“或者trim()之后(” ")为空字符:

2、集合转对应类型的数组

```java
List<String> sampleList = Arrays.asList("张三", "java 11");
// array = {"张三", "java 11"};
String[] array = sampleList.toArray(String[]::new);
```

3、`var`可以用于修饰Lambda局部变量

4、`HttpClient支持HTTP2`，从 Java 11开始，这个API 现在是最终版本，可以在标准库包 java.net 中使用。

5、**ZGC垃圾回收器**

- GC暂停时间不会超过10毫秒
- 既能处理几百兆的小堆，也能处理几个T的大堆
- 和G1相比，应用吞吐能力不会下降超过15%
- 为未来的GC功能和利用colord指针以及Load barriers优化奠定了基础

#### DDD设计模式

领域设计驱动(Domain Driven Design)

#### Nacos集群怎么保证数据一致性

1、一般是先同步到一个节点，然后分发数据

#### Dubbo3新特性

#### MySQL设计范式



---

### 大希地

#### Spring 中事务传播机制，Transation失效场景？

#### aop几种通知类型？注解类型？

五种

1、`前置通知`，在方法执行前通知，@Before(value = "")

2、`环绕通知`，可以将要执行的方法(point.proceed())，进行包裹执行，可以在前后添加需要执行的操作，@Around(value = "")

3、`后置通知`，在方法正常执行完通知，可以访问到方法的返回值，@AfterReturning(value = "")

4、`异常通知`：在方法出现异常时进行通知,可以访问到异常对象，且可以指定在出现特定异常时在执行通知。@AfterThrowing(value = “”)

5、`方法执行后通知`： 在目标方法执行后无论是否发生异常，执行通知,不能访问目标方法的执行的结果。@After(value = “”)

同一个方法被多个Aspect类拦截时，可以使用`@Order注解指定顺序`。

#### Shiro单点登录原理？

#### token、session、cookie的区别？

1. **token**是 服务经过计算发给客户端的，服务不保存，每次客户端来请求，经过解密等计算来验证是否是自己下发的

- token存在哪儿都行，客户端可存放在localstorage或者cookie，而服务器端则会存放于数据库(服务器端的session是直接放在内存中的)
- cookie举例:服务员看你的身份证后，给你一个编号，以后，进行任何操作，都出示编号，然后服务员再去查看你是谁token举例:直接给服务员看自己的身份证

2. **session**是服务本地保存，发给客户端，客户端每次访问都带着，直接和服务的session比对

3. **cookie**是保存在客户端上的一些基本信息，服务不保存，每次请求时客户端带上cookie，里面有一些账户密码，浏览记录什么的

- cookie是不可跨域名的。
- cookie的有效期,maxage决定着cookie的有效期，单位为秒。

#### xxx-job工作原理，选择服务器机制

#### redis分布式锁如何实现？



---

### 互灵科技

##### Spring Bean管理过程，属性设置，循环依赖构造方法注入能解决吗？

##### RabbitMQ消息传输有几种方式

##### 硬件方面，问了很多数据之间传输协议



### 量子科技

#### Spring Boot装配过程

#### Mybatis-Plus拦截器？解析SQL过程

`Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能`，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

