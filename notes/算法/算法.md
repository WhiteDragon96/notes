### 数组

#### 二分法

#### 双指针法

####  滑动窗口

![](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)



---



### 哈希表

- 数组 num[i]++;
- 比较两个数组是否相等 Arrays.equals(a,b)

#### 常见的三种哈希结构

- 数组
- set （集合）
- map(映射)



### 栈和队列

![image-20220711093959075](https://img-blog.csdnimg.cn/20210104235346563.png)

栈和队列的原理大家应该很熟悉了，`队列是先进先出`，`栈是先进后出`。

![image-20220711093959075](https://img-blog.csdnimg.cn/20210104235434905.png)

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。



### 二叉树

```java
public class TreeNode {

    int val;
    TreeNode leftNode;
    TreeNode rightNode;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode leftNode, TreeNode rightNode) {
        this.val = val;
        this.leftNode = leftNode;
        this.rightNode = rightNode;
    }
}
```



### 回溯算法(backtracking)

- 回溯搜索的遍历过程

![](https://img-blog.csdnimg.cn/20210130173631174.png)

回溯函数遍历过程伪代码如下：

```java
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

backtracking这里自己调用自己，实现递归。

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

