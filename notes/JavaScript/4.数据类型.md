- [原始类型的方法](#原始类型的方法)
- [数字类型](#数字类型)
  - [十六进制，二进制和八进制数字](#十六进制二进制和八进制数字)
  - [测试：isFinite 和 isNaN](#测试isfinite-和-isnan)
  - [Object.is 进行比较](#objectis-进行比较)
  - [parseInt 和 parseFloat](#parseint-和-parsefloat)
    - [parseInt(str, radix)` 的第二个参数](#parseintstr-radix-的第二个参数)
- [字符串](#字符串)
  - [引号（Quotes）](#引号quotes)
- [数组](#数组)
  - [pop/push, shift/unshift 方法](#poppush-shiftunshift-方法)
  - [循环](#循环)
  - [数组方法](#数组方法)
  - [遍历：forEach](#遍历foreach)
  - [indexOf/lastIndexOf 和 includes](#indexoflastindexof-和-includes)
  - [find 和 findIndex](#find-和-findindex)
  - [map 转换数组](#map-转换数组)
  - [sort(fn) 排序](#sortfn-排序)
  - [reverse](#reverse)
  - [split 和 join](#split-和-join)
  - [reduce/reduceRight](#reducereduceright)
- [Map and Set（映射和集合）](#map-and-set映射和集合)
  - [Set](#set)
  - [Set 迭代（iteration）](#set-迭代iteration)
- [WeakMap](#weakmap)
- [Object.keys，values，entries](#objectkeysvaluesentries)
  - [转换对象](#转换对象)
- [日期和时间](#日期和时间)
  - [创建](#创建)
- [JSON 方法，toJSON](#json-方法tojson)
  - [JSON.stringify](#jsonstringify)

### 原始类型的方法
一个原始值：

- 是原始类型中的一种值。
- 在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined

一个对象：

- 能够存储多个值作为属性。
- 可以使用大括号 {} 创建对象，例如：{name: "John", age: 30}。JavaScript 中还有其他种类的对象，例如函数就是对象。

### 数字类型
在现代 JavaScript 中，数字（number）有两种类型：

1. JavaScript 中的常规数字以 64 位的格式 IEEE-754 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。

2. BigInt 数字，用于表示任意长度的整数。有时会需要它们，因为常规数字不能超过 253 或小于 -253。由于仅在少数特殊领域才会用到 BigInt，因此我们在特殊的章节 BigInt 中对其进行了介绍。

```JavaScript
    let billion = 1e9;  // 10 亿，字面意思：数字 1 后面跟 9 个 0

    let ms = 1e-6; // 1 的左边有 6 个 0
```
#### 十六进制，二进制和八进制数字
十六进制 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：0x，然后是数字。

```JavaScript
    console.log(0xff) //255

    let num = 255;
    console.log(num.toString(16));  // ff
    console.log(num.toString(2));  // 11111111
```
请注意，<b>toFixed</b> 总是返回一个字符串。它确保小数点后有 2 位数字。如果我们有一个电子购物网站，并需要显示 ¥ 0.30，这实际上很方便。对于其他情况，我们可以使用一元加号将其强制转换为一个数字：
``` JavaScript
    let sum = 0.1 + 0.2;
    console.log( +sum.toFixed(2) ); // 0.3
```
#### 测试：isFinite 和 isNaN
- isNaN(value) 将其参数转换为数字，然后测试它是否为 NaN
``` JavaScript
    console.log( isNaN(NaN) ); // true
    console.log( isNaN("str") ); // true
```
但是我们需要这个函数吗？我们不能只使用 === NaN 比较吗？不好意思，这不行。值 “NaN” 是独一无二的，它不等于任何东西，包括它自身：
console.log( NaN === NaN ); // false
- isFinite(value) 将其参数转换为数字，如果是常规数字，则返回 true，而不是 NaN/Infinity/-Infinity：
``` JavaScript
    console.log( isFinite("15") ); // true
    console.log( isFinite("str") ); // false，因为是一个特殊的值：NaN
    console.log( isFinite(Infinity) ); // false，因为是一个特殊的值：Infinity
```
#### Object.is 进行比较
它适用于 NaN：Object.is（NaN，NaN）=== true，这是件好事。

#### parseInt 和 parseFloat

使用加号 + 或 Number() 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：
``` JavaScript
    console.log( +"100px" ); // NaN
```
但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 "100px" 或 "12pt"。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 "19€"，并希望从中提取出一个数值。

这就是 parseInt 和 parseFloat 的作用。
它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 parseInt 返回一个整数，而 parseFloat 返回一个浮点数：

``` JavaScript
    console.log( parseInt('100px') ); // 100
    console.log( parseFloat('12.5em') ); // 12.5

    console.log( parseInt('12.3') ); // 12，只有整数部分被返回了
    console.log( parseFloat('12.3.4') ); // 12.3，在第二个点出停止了读取
```
##### parseInt(str, radix)` 的第二个参数
parseInt() 函数具有可选的第二个参数。它指定了数字系统的基数，因此 parseInt 还可以解析十六进制数字、二进制数字等的字符串：
``` JavaScript
    console.log( parseInt('0xff', 16) ); // 255
    console.log( parseInt('ff', 16) ); // 255，没有 0x 仍然有效

    console.log( parseInt('2n9c', 36) ); // 123456
```

### 字符串

#### 引号（Quotes）
``` JavaScript
    let single = 'single-quoted';
    let double = "double-quoted";

    let backticks = `backticks`;
```
单引号和双引号基本相同。但是，反引号允许我们通过 ${…} 将任何表达式嵌入到字符串中：

```JavaScript
    let backticks = `1 + 1 = ${1+1}`
    console.log(backticks);
    // 使用反引号的另一个优点是它们允许字符串跨行：
    let guestList = `Guest:
    John
    Mary
    `;
    console.log(guestList);
```

<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车：不单独使用。Windows 文本文件使用两个字符 <code>\r\n</code> 的组合来表示换行。</td>
</tr>
<tr>
<td><code>\'</code>, <code>\"</code></td>
<td>引号</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符</td>
</tr>
<tr>
<td><code>\b</code>, <code>\f</code>, <code>\v</code></td>
<td>退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。</td>
</tr>
<tr>
<td><code>\xXX</code></td>
<td>具有给定十六进制 Unicode <code>XX</code> 的 Unicode 字符，例如：<code>'\x7A'</code> 和 <code>'z'</code> 相同。</td>
</tr>
<tr>
<td><code>\uXXXX</code></td>
<td>以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 <code>©</code> 的 unicode。它必须正好是 4 个十六进制数字。</td>
</tr>
<tr>
<td><code>\u{X…XXXXXX}</code>（1 到 6 个十六进制字符）</td>
<td>具有给定 UTF-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。</td>
</tr>
</tbody>
</table>


- 我们也可以使用 for..of 遍历字符：

```JavaScript
    for (let char of "Hello") {
    console.log(char); // H,e,l,l,o（char 变为 "H"，然后是 "e"，然后是 "l" 等）
  }

  let str = 'stringify';
  console.log(str.slice(2,6)); // 从 start 到 end（不含 end）
  console.log(str.substr(2,4)); // 'ring'，从位置 2 开始，获取 4 个字符
  console.log(str.substring(2,6)); // 	start 与 end 之间（包括 start，但不包括 end）	负值代表 0
```

### 数组
- 数组可以存储任何类型的元素。

```JavaScript
    // 混合值
    let arr = [ 'Apple', { name: 'John' }, true, function() { console.log('hello'); } ];

    // 获取索引为 1 的对象然后显示它的 name
    console.log( arr[1].name ); // John

    // 获取索引为 3 的函数并执行
    arr[3](); // hello
```

#### pop/push, shift/unshift 方法

- push 在末端添加一个元素.
- shift 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。
- pop 从末端取出一个元素.

#### 循环

``` JavaScript
    let arr = ['Apple','Orange','Banana'];
  // 遍历数组最古老的方式就是 for 循环：
    for (let i = 0; i < arr.length; i++) {
    const element = arr[i];
    console.error(element);
    }
    // 但对于数组来说还有另一种循环方式，for..of：
    for(let fruit of arr){
        console.log(fruit);
    }

    // 技术上来讲，因为数组也是对象，所以使用 for..in 也是可以的：
    for(let i in arr){
        console.log(arr[i]);
    }
    // 通常来说，我们不应该用 for..in 来处理数组。
```

#### 数组方法
- splice
  <pre class="line-numbers  language-javascript"><span class="line-numbers-rows"><span></span></span><code class=" language-javascript">arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>start<span class="token punctuation">[</span><span class="token punctuation">,</span> deleteCount<span class="token punctuation">,</span> elem1<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">,</span> elemN<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>


  它从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, ..., elemN。最后返回已被删除元素的数组。

  ```JavaScript
    let arr = ["I", "study", "JavaScript", "right", "now"];

    // remove 3 first elements and replace them with another
    arr.splice(0, 3, "Let's", "dance");

    console.log( arr ) // now ["Let's", "dance", "right", "now"]
  ```
  我们可以将 deleteCount 设置为 0，splice 方法就能够插入元素而不用删除任何元素

- slice
``` JavaScript
    arr.slice([start], [end])
```
它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。

- concat
arr.concat 创建一个新数组，其中包含来自于其他数组和其他项的值。
``` JavaScript
    arr.concat(arg1, arg2...)

    let arr = [1, 2];

    // create an array from: arr and [3,4]
    console.log( arr.concat([3, 4]) ); // 1,2,3,4

    // create an array from: arr and [3,4] and [5,6]
    console.log( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

    // create an array from: arr and [3,4], then add values 5 and 6
    console.log( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

#### 遍历：forEach
arr.forEach 方法允许为数组的每个元素都运行一个函数。
```JavaScript
    function prints(str){
        console.log('Hello ',str);
    }
    arr.forEach(prints);

    arr.forEach((item,index,array) => {
    console.log(`${item} is at index ${index} in ${array}`);
    });
```

#### indexOf/lastIndexOf 和 includes
- arr.indexOf(item, from) 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。
- arr.lastIndexOf(item, from) —— 和上面相同，只是从右向左搜索。
- arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。

#### find 和 findIndex
```JavaScript
    let result = arr.find(function(item, index, array) {
    // 如果返回 true，则返回 item 并停止迭代
    // 对于假值（falsy）的情况，则返回 undefined
    });
```
如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。
```JavaScript
    let users = [
    {id: 1, name: "John"},
    {id: 2, name: "Pete"},
    {id: 3, name: "Mary"}
    ];

    let user = users.find(item => item.id == 1);

    console.log(user.name); // John
```

- filter

find 方法搜索的是使函数返回 true 的第一个（单个）元素。

如果需要匹配的有很多，我们可以使用 arr.filter(fn)。

语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组：
```JavaScript
    let users = [
    {id: 1, name: "John"},
    {id: 2, name: "Pete"},
    {id: 3, name: "Mary"}
    ];

    // 返回前两个用户的数组
    let someUsers = users.filter(item => item.id < 3);

    console.log(someUsers.length); // 2
```

#### map 转换数组
```JavaScript
    let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
    console.log(lengths); // 5,7,6
```

#### sort(fn) 排序

```JavaScript
    let arr = [ 1, 2, 15 ];

    // 该方法重新排列 arr 的内容
    arr.sort();

    alert( arr );  // 1, 15, 2
```
要使用我们自己的排序顺序，我们需要提供一个函数作为 arr.sort() 的参数。
``` JavaScript
    function compare(a, b) {
    if (a > b) return 1; // 如果第一个值比第二个值大
    if (a == b) return 0; // 如果两个值相等
    if (a < b) return -1; // 如果第一个值比第二个值小
    }

    numbers.sort(compareNumber);
```
#### reverse
arr.reverse 方法用于颠倒 arr 中元素的顺序。

#### split 和 join
``` JavaScript 
    let names = 'Bilbo, Gandalf, Nazgul';

    let arr = names.split(', ');

    for (let name of arr) {
    alert( `A message to ${name}.` ); // A message to Bilbo（和其他名字）
    }
```

arr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。
``` JavaScript 
   let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

    let str = arr.join(';'); // 使用分号 ; 将数组粘合成字符串

    alert( str ); // Bilbo;Gandalf;Nazgul
```

#### reduce/reduceRight
```JavaScript
    let value = arr.reduce(function(accumulator, item, index, array) {
    // ...
    }, [initial]);
```
- accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。
- item —— 当前的数组元素。
- index —— 当前索引。
- arr —— 数组本身。
```JavaScript
    let arr = [1, 2, 3, 4, 5];

    let result = arr.reduce((sum, current) => sum + current, 0);

    alert(result); // 15
```

### Map and Set（映射和集合）
map方法属性：
- new Map() —— 创建 map。
- map.set(key, value) —— 根据键存储值。
- map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。
- map.has(key) —— 如果 key 存在则返回 true，否则返回 false。
- map.delete(key) —— 删除指定键的值。
- map.clear() —— 清空 map。
- map.size —— 返回当前元素个数。

map foreach:
```JavaScript
    // 对每个键值对 (key, value) 运行 forEach 函数
    recipeMap.forEach( (value, key, map) => {
    alert(`${key}: ${value}`); // cucumber: 500 etc
    });
```

- Object.entries：从对象创建 Map
- Object.fromEntries：从 Map 创建对象

``` JavaScript
    let obj = {
    name: "John",
    age: 30
    };
    
    let mapObj = new Map(Object.entries(obj));
    console.log( mapObj.get('name') ); // John
    
```

#### Set
Set 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。

- new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。
- set.add(value) —— 添加一个值，返回 set 本身
- set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。
- set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。
- set.clear() —— 清空 set。
- set.size —— 返回元素个数。
  
#### Set 迭代（iteration）
我们可以使用 for..of 或 forEach 来遍历 Set：

```JavaScript 
    let set = new Set(["oranges", "apples", "bananas"]);

    for (let value of set) alert(value);

    // 与 forEach 相同：
    set.forEach((value, valueAgain, set) => {
    alert(value);
    });
```

### WeakMap
WeakMap 和 Map 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值：
``` JavaScript 
    let weakMap = new WeakMap();

    let obj = {};

    weakMap.set(obj, "ok"); // 正常工作（以对象作为键）

    // 不能使用字符串作为键
    weakMap.set("test", "Whoops"); // Error，因为 "test" 不是一个对象
```
现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。

```JavaScript

    let john = { name: "John" };

    let weakMap = new WeakMap();
    weakMap.set(john, "...");

    john = null; // 覆盖引用

    // john 被从内存中删除了！
```

WeakMap 不支持迭代以及 keys()，values() 和 entries() 方法。所以没有办法获取 WeakMap 的所有键或值。

WeakMap 只有以下的方法：
- weakMap.get(key)
- weakMap.set(key, value)
- weakMap.delete(key)
- weakMap.has(key)
  
### Object.keys，values，entries

对于普通对象，下列这些方法是可用的：

- Object.keys(obj) —— 返回一个包含该对象所有的键的数组。
- Object.values(obj) —— 返回一个包含该对象所有的值的数组。
- Object.entries(obj) —— 返回一个包含该对象所有 [key, value] 键值对的数组。

``` JavaScript

let user = {
    name: 'Tom',
    age: 18,
    heitht: 190
}


console.log(Object.keys(user)); // [ 'name', 'age', 'heitht' ]
console.log(Object.values(user)); // [ 'Tom', 18, 190 ]
console.log(Object.entries(user)); // [ [ 'name', 'Tom' ], [ 'age', 18 ], [ 'heitht', 190 ] ]

// 遍历
for(let value of Object.values(user)){
    console.log(value);
}

let doublePrices = Object.fromEntries(
    // 转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象
    Object.entries(user).map(([key, value]) => [key, value * 2])
  );
```

#### 转换对象
1. 使用 Object.entries(obj) 从 obj 获取由键/值对组成的数组。
2. 对该数组使用数组方法，例如 map。
3. 对结果数组使用 Object.fromEntries(array) 方法，将结果转回成对象。

### 日期和时间
#### 创建
new Date(year, month, date, hours, minutes, seconds, ms)
使用当前时区中的给定组件创建日期。只有前两个参数是必须的。

- year 必须是四位数：2013 是合法的，98 是不合法的。
- month 计数从 0（一月）开始，到 11（十二月）结束。
- date 是当月的具体某一天，如果缺失，则为默认值 1。
如果 hours/minutes/seconds/ms 缺失，则均为默认值 0。

### JSON 方法，toJSON

#### JSON.stringify

- JSON.stringify 将对象转换为 JSON。
- JSON.parse 将 JSON 转换回对象。